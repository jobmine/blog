<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>软件设计模式 (Software Design Pattern) 之一二 | 卢卡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="直接跳到最后总结与目录
很久很久以前，一所大学只有几个学生。那个时候，如果学校要记录所有学生的信息只要用一张纸，写下所有人的名字和信息就可以，比如：



姓名
性别
年龄




张三
男
19


李四
男
18


王二麻子
女
18



在他们上课之后，学校遇到了一个难题，每个学生都有很多科的成绩需要登记。所以表格就变成了这个样子：



姓名
性别
年龄
高数
政治
英文
历史
文学">
<meta property="og:type" content="article">
<meta property="og:title" content="软件设计模式 (Software Design Pattern) 之一二">
<meta property="og:url" content="http://jobmine.github.io/blog/2014/08/08/software-pattern/">
<meta property="og:site_name" content="卢卡">
<meta property="og:description" content="直接跳到最后总结与目录
很久很久以前，一所大学只有几个学生。那个时候，如果学校要记录所有学生的信息只要用一张纸，写下所有人的名字和信息就可以，比如：



姓名
性别
年龄




张三
男
19


李四
男
18


王二麻子
女
18



在他们上课之后，学校遇到了一个难题，每个学生都有很多科的成绩需要登记。所以表格就变成了这个样子：



姓名
性别
年龄
高数
政治
英文
历史
文学">
<meta property="og:image" content="https://dl.dropboxusercontent.com/u/43681877/temp/facade.jpg">
<meta property="og:image" content="https://dl.dropboxusercontent.com/u/43681877/temp/factory.jpg">
<meta property="og:image" content="https://dl.dropboxusercontent.com/u/43681877/temp/adapter.jpg">
<meta property="og:image" content="https://dl.dropboxusercontent.com/u/43681877/temp/strategy.jpg">
<meta property="og:image" content="https://dl.dropboxusercontent.com/u/43681877/temp/observer.jpg">
<meta property="og:image" content="https://dl.dropboxusercontent.com/u/43681877/temp/observer2.jpg">
<meta property="og:image" content="https://dl.dropboxusercontent.com/u/43681877/temp/mvc.jpg">
<meta property="og:image" content="https://dl.dropboxusercontent.com/u/43681877/temp/decorator.jpg">
<meta property="og:image" content="https://dl.dropboxusercontent.com/u/43681877/temp/composite.jpg">
<meta property="og:image" content="https://dl.dropboxusercontent.com/u/43681877/temp/composite2.jpg">
<meta property="og:image" content="https://dl.dropboxusercontent.com/u/43681877/temp/composite3.jpg">
<meta property="og:image" content="https://dl.dropboxusercontent.com/u/43681877/temp/composite2.jpg">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="软件设计模式 (Software Design Pattern) 之一二">
<meta name="twitter:description" content="直接跳到最后总结与目录
很久很久以前，一所大学只有几个学生。那个时候，如果学校要记录所有学生的信息只要用一张纸，写下所有人的名字和信息就可以，比如：



姓名
性别
年龄




张三
男
19


李四
男
18


王二麻子
女
18



在他们上课之后，学校遇到了一个难题，每个学生都有很多科的成绩需要登记。所以表格就变成了这个样子：



姓名
性别
年龄
高数
政治
英文
历史
文学">

  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/blog/css/style.css" type="text/css">

  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-53644847-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog//" id="logo">卢卡</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog//" id="subtitle">大道极简</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog//">杂记</a>
        
          <a class="main-nav-link" href="/blog//">个人</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://jobmine.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-software-pattern" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2014/08/08/software-pattern/" class="article-date">
  <time datetime="2014-08-08T21:52:11.000Z" itemprop="datePublished">8月 8 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      软件设计模式 (Software Design Pattern) 之一二
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a id="top"></a><br><a href="#content">直接跳到最后总结与目录</a></p>
<p>很久很久以前，一所大学只有几个学生。那个时候，如果学校要记录所有学生的信息只要用一张纸，写下所有人的名字和信息就可以，比如：</p>
<table>
<thead>
<tr>
<th style="text-align:center">姓名</th>
<th style="text-align:center">性别</th>
<th style="text-align:center">年龄</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">张三</td>
<td style="text-align:center">男</td>
<td style="text-align:center">19</td>
</tr>
<tr>
<td style="text-align:center">李四</td>
<td style="text-align:center">男</td>
<td style="text-align:center">18</td>
</tr>
<tr>
<td style="text-align:center">王二麻子</td>
<td style="text-align:center">女</td>
<td style="text-align:center">18</td>
</tr>
</tbody>
</table>
<p>在他们上课之后，学校遇到了一个难题，每个学生都有很多科的成绩需要登记。所以表格就变成了这个样子：</p>
<table>
<thead>
<tr>
<th style="text-align:center">姓名</th>
<th style="text-align:center">性别</th>
<th style="text-align:center">年龄</th>
<th style="text-align:center">高数</th>
<th style="text-align:center">政治</th>
<th style="text-align:center">英文</th>
<th style="text-align:center">历史</th>
<th style="text-align:center">文学</th>
<th style="text-align:center">演讲</th>
<th style="text-align:center">地理</th>
<th style="text-align:center">摄影</th>
<th style="text-align:center">物理</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">张三</td>
<td style="text-align:center">男</td>
<td style="text-align:center">19</td>
<td style="text-align:center">86</td>
<td style="text-align:center">83</td>
<td style="text-align:center">91</td>
<td style="text-align:center">92</td>
<td style="text-align:center">97</td>
<td style="text-align:center">82</td>
<td style="text-align:center">84</td>
<td style="text-align:center">91</td>
<td style="text-align:center">92</td>
</tr>
<tr>
<td style="text-align:center">李四</td>
<td style="text-align:center">男</td>
<td style="text-align:center">18</td>
<td style="text-align:center">97</td>
<td style="text-align:center">74</td>
<td style="text-align:center">79</td>
<td style="text-align:center">72</td>
<td style="text-align:center">97</td>
<td style="text-align:center">62</td>
<td style="text-align:center">84</td>
<td style="text-align:center">71</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">王二麻子</td>
<td style="text-align:center">女</td>
<td style="text-align:center">18</td>
<td style="text-align:center">99</td>
<td style="text-align:center">83</td>
<td style="text-align:center">91</td>
<td style="text-align:center">76</td>
<td style="text-align:center">65</td>
<td style="text-align:center">82</td>
<td style="text-align:center">84</td>
<td style="text-align:center">99</td>
<td style="text-align:center">99</td>
</tr>
</tbody>
</table>
<p>后来，他们被分到了不同的专业，学校为了重复利用之前的表格，在表格上直接加了内容：</p>
<table>
<thead>
<tr>
<th style="text-align:center">姓名</th>
<th style="text-align:center">性别</th>
<th style="text-align:center">年龄</th>
<th style="text-align:center">学院</th>
<th style="text-align:center">专业</th>
<th style="text-align:center">高数</th>
<th style="text-align:center">政治</th>
<th>英文</th>
<th>… </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">张三</td>
<td style="text-align:center">男</td>
<td style="text-align:center">19</td>
<td style="text-align:center">文学院</td>
<td style="text-align:center">历史系</td>
<td style="text-align:center">86</td>
<td style="text-align:center">83</td>
<td>91</td>
<td>…</td>
</tr>
<tr>
<td style="text-align:center">李四</td>
<td style="text-align:center">男</td>
<td style="text-align:center">18</td>
<td style="text-align:center">理学院</td>
<td style="text-align:center">数学系</td>
<td style="text-align:center">97</td>
<td style="text-align:center">74</td>
<td>79</td>
<td>…</td>
</tr>
<tr>
<td style="text-align:center">王二麻子</td>
<td style="text-align:center">女</td>
<td style="text-align:center">18</td>
<td style="text-align:center">理学院</td>
<td style="text-align:center">物理系</td>
<td style="text-align:center">99</td>
<td style="text-align:center">83</td>
<td>91</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>再后来，学校又多了很多人，于是这个表格被无限的拉长了：</p>
<table>
<thead>
<tr>
<th style="text-align:center">姓名</th>
<th style="text-align:center">性别</th>
<th style="text-align:center">年龄</th>
<th style="text-align:center">学院</th>
<th style="text-align:center">专业</th>
<th style="text-align:center">高数</th>
<th style="text-align:center">政治</th>
<th>英文</th>
<th>… </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">张三</td>
<td style="text-align:center">男</td>
<td style="text-align:center">19</td>
<td style="text-align:center">文学院</td>
<td style="text-align:center">历史系</td>
<td style="text-align:center">86</td>
<td style="text-align:center">83</td>
<td>91</td>
<td>…</td>
</tr>
<tr>
<td style="text-align:center">李四</td>
<td style="text-align:center">男</td>
<td style="text-align:center">18</td>
<td style="text-align:center">理学院</td>
<td style="text-align:center">数学系</td>
<td style="text-align:center">97</td>
<td style="text-align:center">74</td>
<td>79</td>
<td>…</td>
</tr>
<tr>
<td style="text-align:center">王二麻子</td>
<td style="text-align:center">女</td>
<td style="text-align:center">18</td>
<td style="text-align:center">理学院</td>
<td style="text-align:center">物理系</td>
<td style="text-align:center">99</td>
<td style="text-align:center">83</td>
<td>91</td>
<td>…</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td>…</td>
<td>… </td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td>…</td>
<td>… </td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td>…</td>
<td>… </td>
</tr>
</tbody>
</table>
<p>后来……</p>
<p>到这里，大家会发现一个问题。最初的表格设计没有考虑很多因素，导致后期表格不够用，插入和寻找的效率很低，占地方多，而且不容易维护。很多开发者在开发软件的时候也有类似经历，因为最初设计不够完善，导致后期不论是添加功能还是使用上，都十分的不便。</p>
<p>1978年，奥地利建筑师 <cite>Christopher Alexander <a href="http://en.wikipedia.org/wiki/Software_design_pattern" target="_blank" rel="external">1</a></cite> 首先提出可以通过经验总结一些设计模式 (Design Patterns) 以供后人在设计时借鉴。计算机软件领域，则在1995年时，由<cite>四人帮 <a href="http://en.wikipedia.org/wiki/Software_design_pattern" target="_blank" rel="external">1</a></cite> (Gang of Four / Gamma et al) 在《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software，ISBN 0-201-63361-2) 中提出。四人帮共提出了23种不同的设计模式。台湾自由撰稿人 <cite>Justin Lin <a href="http://openhome.cc/Gossip/DesignPattern/" target="_blank" rel="external">2</a></cite> 在博客中很详细的描述了这23种设计模式的定义以及用法，本文也会在定义部分引用 Justin 的原文。</p>
<p>简单的废话之后来切入正题。本文是笔者在滑铁卢大学 CS247 (CS247 : Software Abstraction and Specification, 教授：Joanne Atlee) 的学习笔记，所以主要讨论的是课中提及的23种设计模式中的10种。本文编程语言使用C++。</p>
<hr>
<h2 id="领进门">领进门</h2>
<p>设计模式不是人们发明出来，而是人们发现的。这就像买西瓜，前人发现西瓜拍起来响的，纹路清晰的比较甜，这是一个已经存在的事实，被人们发现，并用于挑选西瓜，而不是我们告诉西瓜，你要这样长才会甜。设计模式也是一样的，前人们发现了这些十分有效的设计模式，所以我们学习、使用这些模式进行软件设计，而不是我们发明了这种方法，让软件这样被设计。</p>
<p>所以说，如果我们先被告知一种设计模式的概念和定义，再去研究怎么使用，就非常本末倒置了。学习设计模式最好的办法反倒是在你大量编程、实现代码的时候，发现了自己的代码很多地方不好用，而去寻找解决的办法。</p>
<p>所以本文的思路是，首先提出复杂的情况，然后提出解决的办法，最后引入四人帮提出的设计方法，给出定义。</p>
<hr>
<h2 id="学生成绩办公室_-_Façade"><a id="facade pattern"></a>学生成绩办公室 - Façade</h2>
<p><a href="#content">跳到所有模式目录</a> / <a href="#top">回到全文顶端</a></p>
<p>还记得刚才那所悲催的学校吗？我们继续拿他开刀。现在学校已经有了两万学生，三千老师，几百种不同的课。所有的课都会有不同的期末成绩，学生考试，考完试以后教授批改卷子，然后给出最后分数。如果一个学生有 5 门课，他就要去分别找 5 个教授。如果一个教授有 200 个学生，就要等在办公室，等着 200 次询问和查找。这不但容易出错（拿错卷子，成绩没有记录，浪费时间，浪费精力，容易丢失等等），而且对学生考试后的身、心、灵都造成了极大的疲惫，也给投机取巧的学生带来偷偷改成绩的机会。</p>
<p>所以怎么解决？我相信大家都会知道，很好的一个解决办法就是设立一个学生成绩办公室，那么教授批改了成绩之后，把卷子统一交给成绩办公室上分、记录。学生如果要查询成绩，可以直接到学习成绩办公室根据自己的名字查询所有成绩。也就是说，我们避免了教授和学生的直接接触（多对多接触），而通过办公室改成了间接接触（多对一对多）。用一个图来更直观的说明：</p>
<p><img src="https://dl.dropboxusercontent.com/u/43681877/temp/facade.jpg" alt="有了学生成绩办公室之前之后"> </p>
<p>使用了这种方法之后，教授和学生都可以减少很多劳动。而且学生和教授数量的增加也不会再造成很大影响。不论从安全角度或是效率角度都是绝对性的提升。</p>
<p>一种类似的方法在软件设计中叫做外观模式（Façade Pattern）。</p>
<blockquote>
<p>A <strong>facade</strong> is an object that provides a simplified interface to a larger body of code, such as a class library. </p>
</blockquote>
<p>外观模式为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。在我们的例子中，可以把学生想象为客户（Client），教授和办公室是学校工作人员为单位的子系统（Sub-System），成绩办公室就是 Façade，而每个教授就是不同的 Packages。使用这种方法后，Clients 在访问 packages 的时候，程序提供了一个高层对外接口，可以有效地简化 packages 的使用，隐藏依赖的 packages，降低耦合，十分利于分工合作。</p>
<p>而 Façade 的缺点也显而易见。学生需要掌握一门新的技能 - 去成绩办公室问成绩，而不能直接问教授，其中就缺少了很多方便性和活动性。</p>
<p>一个代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> CPU {}</div><div class="line"><span class="keyword">class</span> Memory {}</div><div class="line"><span class="keyword">class</span> HardDrive {}</div><div class="line"><span class="keyword">class</span> Computer {         <span class="comment">// Façade</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">void</span> startComputer() {</div><div class="line">        cpu.freeze();</div><div class="line">        memory.load(BOOT_ADDRESS, hardDrive.read(BOOT_SECTOR, SECTOR_SIZE));</div><div class="line">        cpu.jump(BOOT_ADDRESS);</div><div class="line">        cpu.execute();</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">class</span> You {              <span class="comment">// Client</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">void</span> start(String[] args) {</div><div class="line">        Computer facade = <span class="keyword">new</span> Computer();</div><div class="line">        facade.startComputer();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Source: http://zh.wikipedia.org/wiki/外觀模式</span></div></pre></td></tr></table></figure>

<hr>
<h2 id="_学院注册办公室_-_Factory_Method"><a id="factory method pattern"></a> 学院注册办公室 - Factory Method</h2>
<p><a href="#content">跳到所有模式目录</a> / <a href="#top">回到全文顶端</a></p>
<p>学生查成绩的问题有着落了。可是新学期来了，学校又有了一个新的问题：学校一共有 6 个学院，分别是工程学院、数学学院、文科学院、科学学院、环境学院、应用健康学院。新生入学了以后要统一在学校注册。现在的流程是这样的：每个学生到了学校之后去同一个地方报道。学校把 6 个学院的所有东西放在一片空地上，然后根据你是哪个学院的为你找出学院专门的制服、专门的购物表、专门宿舍地图等。所以每一个学生来，学校都要在 6 种衣服中选择 1 种给你，再在 6 中传单中找出 1 种给你。这样非常浪费时间，效率很低，而且很容易拿错。</p>
<p>解决方案其实也很简单。我们之前只有一个地方报道，如果我们把报道的地方增加到 6 个，每个学院一个。这样，学生来报道的时候可以直接根据提示去自己的学院。这样，在不同的 6 个地方报道的人，总是会拿到一套相同的东西，这样就不再需要在 6 个中寻找某一个学院的。</p>
<p><img src="https://dl.dropboxusercontent.com/u/43681877/temp/factory.jpg" alt="注册办公室"> </p>
<p>虽然听起来是一个很简单的问题和很显而易见的解决方案，这却是所有软件设计中最常用、最好用的一种设计模式，这种设计模式大量的应用于各种项目中。</p>
<p>我们想另外一个例子，在一家大型汽车工厂，我们要生产 4 种不同型号的车（A, B, C, D)。我们有 8 条生产线，如果这 4 种汽车的市场需求量是相等的，那么如果你是生产线设计者，你会让：</p>
<ul>
<li><p>所有生产线同时生产一辆A，再生产一辆B，一辆C，一辆D，一辆A，一辆B……</p>
</li>
<li><p>每两条生产线连续生产一种型号的车（1, 2 号线生产A，3, 4 号线生产B， ……）</p>
</li>
</ul>
<p>答案毋庸置疑是第二个。背后的原理就是我们现在要介绍的：工厂方法模式（Factory Method Pattern）</p>
<blockquote>
<p><strong>Factory method pattern</strong> is a pattern deals with the problem of creating objects without specifying the exact class of object that will be created.</p>
</blockquote>
<p>以 Justin 举得一个例子来说，如果我们编写一个文件编辑器，它可以支持很多种不同的格式如 DOC, RTF 等。如果我们要写存储的逻辑，每一种格式的存储逻辑都不一样。可是我们使用 Factory Method Pattern 就不需要担心每一种格式的区别，只需要写好逻辑，让子类来定义具体的方法即可。也就是说，这种模式适用于如果你希望在父类中的一个行为是由子类来具体定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Office { <span class="keyword">public</span>: <span class="keyword">virtual</span> ~Office() {} }</div><div class="line"><span class="keyword">class</span> EngineeringOffice : <span class="keyword">public</span> Office {}</div><div class="line"><span class="keyword">class</span> MathOffice : <span class="keyword">public</span> Office {}</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">class</span> Student {}</div><div class="line"><span class="keyword">class</span> EngineeringStudent : <span class="keyword">public</span> Student {}</div><div class="line"><span class="keyword">class</span> MathStudent : <span class="keyword">public</span> Student {}</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>

<hr>
<h2 id="遍历_-_Iterator"><a id="iterator pattern"></a>遍历 - Iterator</h2>
<p><a href="#content">跳到所有模式目录</a> / <a href="#top">回到全文顶端</a></p>
<p>遍历是一个所有程序员都非常熟悉的概念。所谓遍历就是在一个容器中，对每一项数据做某些事情。接下来提出的这个设计模式，既简单又复杂，既易懂又最让人费解。</p>
<p>如果说上面的学生注册办公室问题中，工程学院的学生有 2217 人，办公室接待只有一个人。为了确保来的人都有被接待，那么：</p>
<ol>
<li><p>准备一个计数器，一开始是0，每接待完一个人计数器加 1，计数器一直加到 2217，然后结束。 </p>
</li>
<li><p>告知所有人接待时间是 8:00 到 12:00。这个期间看队伍里有没有人，如果还有人就接待，到时间了并且没有人了就结束。</p>
</li>
</ol>
<p>似乎又是一个显而易见，或者说人类本能的答案，肯定是第二个。可是又有谁没有在自己的项目中出现过这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2177</span>, i++) {</div><div class="line">    <span class="comment">// 接待</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里，我们就通过一个很不全面的例子，引出了一个设计模式：迭代器模式（Iterator pattern）。迭代器与容器息息相关，甚至可以说一个容器没有迭代器就失去了最大的功能。所以，在C++ STL（标准模板库）中，我们常用的容器如 <code>vector</code>, <code>set</code>, <code>string</code> 等等，都自带了默认的迭代器，我们只需要直接使用就可以，而很少需要自己动手实现。</p>
<p>我们来看一个软件设计模式中的迭代器实例。代码实现了上面所描述的注册办公室的例子：<br>首先，我们希望办公室可以看到每个学生是否在队伍中，所以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Office* mathOffice = <span class="keyword">new</span> Office; <span class="comment">// 创建办公室</span></div><div class="line">OfficeIterator* iter = mathOffice -&gt; createIterator(); <span class="comment">// 创建 Iterator</span></div><div class="line">iter -&gt; first(); <span class="comment">// 指针指向队伍中第一个学生</span></div><div class="line"><span class="comment">// 这个循环开始办理每一个在队伍中的学生</span></div><div class="line"><span class="keyword">while</span> ( iter -&gt; hasNext() ) {</div><div class="line">    Student* s = iter -&gt; next();</div><div class="line">    <span class="comment">// ... 安排该学生注册</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>以上便是使用，而不需要在循环中加入 <code>for</code> 循环。<br>可惜，STL 并没有帮我们定义这种 class，所以我们要手动实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> OfficeIterator; <span class="comment">// 在实现办公室迭代器前，我们先实现办公室这个class。</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> Office {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">void</span> newComingStudent(Student*);</div><div class="line">    Student* getStudent(<span class="keyword">int</span>) <span class="keyword">const</span>;</div><div class="line">    <span class="keyword">int</span> size() <span class="keyword">const</span>;</div><div class="line">    OfficeIterator* createIterator();</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// 此处因为随时有新生可能加入到队伍中，我们使用STL提供的vector</span></div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;Student*&gt;</span> students_; </div><div class="line">};</div><div class="line"></div><div class="line">OfficeIterator* Office::createIterator() {</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OfficeIterator(<span class="keyword">this</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来，我们要实现上面的办公室迭代器 <code>class OfficeIterator</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建学生办公室的 Iterator class</span></div><div class="line"><span class="keyword">class</span> OfficeIterator {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    OfficeIterator(Office* o) : student_(o), cursor_(<span class="number">0</span>) {}</div><div class="line">    Student* next();</div><div class="line">    <span class="keyword">bool</span> hasNext() <span class="keyword">const</span>; <span class="comment">// 在下方实现</span></div><div class="line">    <span class="keyword">void</span> first() { cursor_ = <span class="number">0</span>; } <span class="comment">// 指向队伍中第一个学生</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Student* student_; <span class="comment">// 指向工程系学生的队伍</span></div><div class="line">    <span class="keyword">int</span> cursor_;  </div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 看看还有没有学生在队伍中等待被接待</span></div><div class="line"><span class="keyword">bool</span> OfficeIterator::hasNext() <span class="keyword">const</span> {</div><div class="line">    <span class="keyword">return</span> student_ -&gt; size() &gt; cursor_;</div><div class="line">}</div><div class="line"><span class="comment">// 如果有的话，办理下一个学生</span></div><div class="line"></div><div class="line">Student* OfficeIterator::next() {</div><div class="line">    <span class="keyword">if</span> (!OfficeIterator::hasNext()) {</div><div class="line">        <span class="keyword">return</span> NULL;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        Student* nextStudentName = student_ -&gt; getName(cursor_);</div><div class="line">        cursor_ ++;</div><div class="line">        <span class="keyword">return</span> nextStudentName;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样，我们就完成了这个逻辑。还有很多可以完善，比如，如果队伍中没有人了，但是时间还没到，那么我们就每隔五分钟检查一下队伍中是否有 <code>first()</code>，也就是 <code>cursor_ = 0</code> 时。如果有，再开始循环。</p>
<p>好消息是，一个迭代器就这样完成了。坏消息是，我们看到的只是迭代器的冰山一角。</p>
<blockquote>
<p>You can insert only in one end and remove from the other in a <strong>queue</strong> container, but from both ends in a <strong>deque</strong>.</p>
</blockquote>
<p>STL 容器 <code>queue</code> 和 <code>deque</code> 最大的区别就是 <code>queue</code> 只能从后面进，前面出（或反过来），而 <code>deque</code> 可以从两边随便进出。比如刚才的例子中，其实我们就是建造了一个<code>queue</code>容器。</p>
<p>可是新的问题来了：因为后面的同学会等很久，所以办公室决定从队伍的最后面开始发新生手册，这样可以让这些学生打发时间。所以我们这时就需要一个迭代器从一个队伍的最后开始向前遍历。</p>
<p>一个解决办法是，我们让队伍重新排列，最后一个站到第一个，最后第二个站在第二个，重新组成一个队伍，然后从前向后发新生手册。之后再返回来，再继续办理。不过这样效率非常低（而且某种角度很脑残）。所以，我们还需要一个新的迭代器方法。</p>
<p>在 <code>class Office</code> 中加入公共方法 <code>BackOfficeIterator* Office::createBackIterator();</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BackOfficeIterator* Office::createBackIterator() {</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BackOfficeIterator(<span class="keyword">this</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为两种 Iterator 非常相似，下面的代码中，我会对比来写。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这段是重复的 Code 来自上文</span></div><div class="line">OfficeIterator(Office* o) : student_(o), cursor_(<span class="number">0</span>) {}</div><div class="line"><span class="keyword">void</span> OfficeIterator::first() { </div><div class="line">    cursor_ = <span class="number">0</span>; </div><div class="line">} </div><div class="line"><span class="keyword">bool</span> OfficeIterator::hasNext() <span class="keyword">const</span> {</div><div class="line">    <span class="keyword">return</span> student_ -&gt; size() &gt; cursor_;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在新的迭代器 <code>BackOfficeIterator</code> 中修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BackOfficeIterator(Office* o) : student_(o), cursor_(student_ -&gt; size() - <span class="number">1</span>) {}</div><div class="line"><span class="keyword">void</span> BackOfficeIterator::first() { </div><div class="line">    cursor_ = book_ -&gt; size() - <span class="number">1</span>; </div><div class="line">}</div><div class="line"><span class="keyword">bool</span> BackOfficeIterator::hasNext() <span class="keyword">const</span> {</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span> &gt;= cursor_;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>另外还要把 <code>Student* OfficeIterator::next()</code> 中 <code>cursor_ ++;</code> 修改为 <code>cursor_ --;</code>，那么一个反方向的迭代器就写好了。</p>
<p>最后，我们还是引出 Iterator Pattern 的概念：</p>
<blockquote>
<p><strong>Iterator</strong> pattern is a design pattern in which an iterator is used to traverse a container and access the container’s elements.</p>
</blockquote>
<p>很直白的定义，希望大家已经理解。</p>
<hr>
<h2 id="小结">小结</h2>
<p>至此，我们已经描述完了 3 种不同的设计模式。（读者: 不是还有 7 种要说吗！） 恩，别急，我在这里停下来是因为，其实这 23 种不同的设计模式被分成了三大类。我们刚才说过的这三种分别是三大类中的一种设计模式。</p>
<p>四人帮将所有的设计模式分为以下三大类：</p>
<ul>
<li><a id="Creational Patterns"></a>Creational Patterns （创建型模式）：通过创建 (create) <em>合适的 (manner suitable)</em>新的对象来设计软件，使软件更具安全性 (hiding)，封装性 (encapsulating)和可维护性。</li>
<li><a id="Structural Patterns"></a>Structural Patterns （结构型模式）：一以贯之 (identifing a simple way) 的简化软件设计。</li>
<li><a id="Behavioral Patterns"></a>Behavioral Patterns （行为型模式）：通过识别 (identify) 对象之间是怎么交流的，来加强软件交流时的弹性 (flexibility)。</li>
</ul>
<p>我们上文说过的三种设计模式：</p>
<ul>
<li>Factory Method Pattern</li>
<li>Iterator Pattern</li>
<li>Façade Pattern</li>
</ul>
<p>我们来猜一下，这三种模式分别属于什么软件设计模式？</p>
<table>
<thead>
<tr>
<th style="text-align:left">设计模式</th>
<th style="text-align:left">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Factory Method</td>
<td style="text-align:left">?</td>
</tr>
<tr>
<td style="text-align:left">Iterator</td>
<td style="text-align:left">?</td>
</tr>
<tr>
<td style="text-align:left">Façade</td>
<td style="text-align:left">?</td>
</tr>
</tbody>
</table>
<p>其中 Factory Method Pattern 属于创建型模式（Creational），我们让一个办公室变成了 6 个办公室，让学生在一个地方排队变成在 6 个地方排队。某种角度上来说，我们增加了软件的复杂度，不过提升了软件的可复用性和安全性，这从很大的方面上提升了面对对象编程的优势。不过在很多时候，盲目提升软件复杂度（大量使用 Creational Pattern）可能反倒会导致软件更不可用。所以一定要认清问题的本质，慎重使用 Creational Pattern。</p>
<p>其中 Iterator Pattern 是典型的行为型模式 （Behavioral Pattern）。Iterator 提供了一种方法可以在不暴露一个容器中的具体内容的情况下，按照一定要求访问一个其中所有元素。 </p>
<p>Façade Pattern 则是一个结构型模式，我们认清了老师、成绩和学生之间的结构关系，通过一个 Façade Class 来为子系统的一组接口 (Interface) 提供一个统一的界面。避免了结构上的乱七八糟，也简化了客户 (client) 访问这个端口的复杂度（曾经学生要去问不同教授，现在只需要去成绩办公室）。除此之外，也增加了整体的安全性和复用性。</p>
<p>接下来，我们来枚举一下我们后文中也会出现的设计模式：</p>
<p><a id="content"></a></p>
<p><a href="#top">回到最始重新阅读全文</a></p>
<table>
<thead>
<tr>
<th style="text-align:center">目的</th>
<th style="text-align:left">设计模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="#Creational Patterns">Creational</a></td>
<td style="text-align:left"><a href="#factory method pattern"><strong>Factory Method</strong></a></td>
</tr>
<tr>
<td style="text-align:center">↑</td>
<td style="text-align:left"><a href="#singleton pattern">Singleton</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#Structural Patterns">Structural</a></td>
<td style="text-align:left"><a href="#adapter pattern">Adapter</a></td>
</tr>
<tr>
<td style="text-align:center">↑</td>
<td style="text-align:left"><a href="#composite pattern">Composite</a></td>
</tr>
<tr>
<td style="text-align:center">↑</td>
<td style="text-align:left"><a href="#decorator pattern">Decorator</a></td>
</tr>
<tr>
<td style="text-align:center">↑</td>
<td style="text-align:left"><a href="#facade pattern"><strong>Façade</strong></a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#Behavioral Patterns">Behavioral</a></td>
<td style="text-align:left"><a href="#iterator pattern"><strong>Iterator</strong></a></td>
</tr>
<tr>
<td style="text-align:center">↑</td>
<td style="text-align:left"><a href="#observer pattern">Observer</a></td>
</tr>
<tr>
<td style="text-align:center">↑</td>
<td style="text-align:left"><a href="#strategy pattern">Strategy</a></td>
</tr>
<tr>
<td style="text-align:center">↑</td>
<td style="text-align:left"><a href="#template method pattern">Template Method</a></td>
</tr>
<tr>
<td style="text-align:center"><a href="#arch patterns">*Architectural</a></td>
<td style="text-align:left"><a href="#mvc pattern">Model-View-Controller</a></td>
</tr>
</tbody>
</table>
<p>后文中，我会按照顺序说明。<br><a id="arch patterns"></a><br>请注意：最后一种 <strong>Architectural Pattern</strong> 中，我们会介绍一种 MVC (Model-View-Controller) Pattern，这不是四人帮提出23中设计模式中的一个。越过这段不会影响本文其它内容。</p>
<hr>
<h2 id="_苹果做手机，康宁大猩猩做屏幕_-_Singleton"><a id="singleton pattern"></a> 苹果做手机，康宁大猩猩做屏幕 - Singleton</h2>
<p><a href="#content">跳到所有模式目录</a> / <a href="#top">回到全文顶端</a></p>
<p>苹果手机从2007年到现在，从零到第一的背后，必然是优秀的团队与成功的设计。可是苹果会设计所有的每一个细节吗？答案当然是不，每一部iPhone的很多组成部分都来自世界各个厂商。康宁大猩猩玻璃现在广受好评，很多厂商都是用康宁制作的玻璃作为自己手机的屏幕玻璃材质。那么问题就来了：苹果很会设计手机，而康宁很会做玻璃，可是如果让康宁自己做手机，或者让苹果自己发明一种玻璃，可能产品质量就大打折扣，而且两个厂商都不能全心的做自己拿手的东西。</p>
<p>那么怎么办呢？</p>
<p>对，答案就是：康宁会做玻璃，那你就一心一意的做玻璃。苹果你会做手机，你就死心塌地的做手机。一个人干一个人的事。康宁做的玻璃可以让苹果用，三星用，HTC用。苹果也可以挑选康宁家，蓝宝石家，或者别人家。</p>
<p>这种设计方法叫做单例模式（Singleton Pattern），单例单例，顾名思义，就是只有一个实例的意思。</p>
<blockquote>
<p><strong>Singleton Pattern</strong> is a design pattern that restricts the <em>instantiation</em> of a class to one object. </p>
</blockquote>
<p>也就是说，单例对象的类必须保证只有一个实例存在，并提供一个访问这个实例的方法。一般，一个 singleton object 不需要被 destruct。它会随着一段程式的终止而被 deallocate。<br>一段很简单的实现就是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Singleton {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span> Singleton* instance() { <span class="keyword">return</span> &e; }</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> Singleton s;               <span class="comment">// 被保护的 Singleton 的实例</span></div><div class="line">    Singleton(<span class="keyword">const</span> Singleton&);      <span class="comment">// 被保护的 copy-constructor</span></div><div class="line">};</div><div class="line"><span class="comment">// Singleton Singleton::s();</span></div></pre></td></tr></table></figure>

<hr>
<h2 id="_拼图_-_Adapter"><a id="adapter pattern"></a> 拼图 - Adapter</h2>
<p><a href="#content">跳到所有模式目录</a> / <a href="#top">回到全文顶端</a></p>
<p>据称，<a href="http://en.wikipedia.org/wiki/Jigsaw_puzzle" target="_blank" rel="external">第一个商品拼图出现在1760年前后</a>。从那之后，拼图变成了家喻户晓的益智游戏。拼图实际上就是在训练一种解决问题的能力。</p>
<p>一般，在我们的软件不能被别人直接使用的时候，我们的第一个解决方案就是更改软件，使它可以使用。可是如果这样，每个不同的用户我们都要去不停的改变源代码。这样既没有很好地封装性，遇到问题也不容易快速发现、解决。这时，软件和客户之间就有了一层代沟（Gap）。那么解决方案是什么？</p>
<ul>
<li>更改软件以适应客户</li>
<li>更改客户以适应软件</li>
<li>在客户和软件之间建造适应的 class 以适应彼此</li>
</ul>
<p>如果客户和软件都是比较大的独立个体，我们可以选择第三种。这样，我们在不更改源代码的情况下，就可以适应新的要求和接口。</p>
<p><img src="https://dl.dropboxusercontent.com/u/43681877/temp/adapter.jpg" alt="右边蓝色的便是我们的 Adapter class"> </p>
<p>这种设计模式叫做适配器模式 (Adapter Pattern)，它是结构型模式的一种，找出两种结构不能适应的Gap并对症下药解决。</p>
<blockquote>
<p><strong>Adapter pattern</strong> is a software design pattern that allows the interface of an existing class to be used from another interface.</p>
</blockquote>
<p>生活里利用这个设计模式最恰当不过的就是转换插头。我在中国能用的插头拿到美国就不能用，那么当电压没问题的时候，我们只需要一个转接头就可以使用。如果有电压问题，也可以使用一个变压器。美国的电板就代表我们的软件，我们的电器插头就是客户，变压器（或转换插头）就是 adapter classes.</p>
<hr>
<h2 id="_屏幕解锁_-_Strategy"><a id="strategy pattern"></a> 屏幕解锁 - Strategy</h2>
<p><a href="#content">跳到所有模式目录</a> / <a href="#top">回到全文顶端</a></p>
<p>私人信息，重要至极。为了保护手机中的隐私信息，我们都会为他上一个锁。现代的手机里都有各种不同的解锁方式。假设一个手机功能非常全，可以用指纹解锁、人脸识别解锁、声音解锁、眼球解锁、密码解锁、回答问题解锁等等，那么，为了防止客户忘掉，手机一般会同时提供多种解锁。</p>
<p>比如，来到解锁界面，因为你正在吃鸡翅不方便用指纹，那么你就用声音解锁，如果不能说话的时候，就用人脸识别解锁。如果都不行，那就用密码解锁。那么从软件的角度，我们是应该把这一堆解锁方法全写在一起：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">camera.on();                    // 打开照相机</div><div class="line">photo = camera.takephoto();     // 照一张相</div><div class="line">voice.record();                 // 同时在录一段声音</div><div class="line">fingerprint.wait();             // 指纹识别器也同时打开等着指纹</div><div class="line"><span class="keyword">if</span> (photo.exists()) {           // 检查刚才照的照片有没有人…</div><div class="line">// <span class="keyword">...</span></div></pre></td></tr></table></figure>

<p>这样的设计会让手机又费电，又浪费资源，如果未来要更改代码或者增加新功能也十分不便。那么这里我们就有这样一个解决办法：</p>
<p><img src="https://dl.dropboxusercontent.com/u/43681877/temp/strategy.jpg" alt="Strategy Pattern"> </p>
<p>这样，手机会由总解锁算法决定使用哪一种解锁方法并启用相应的继承的算法。从开发的角度上，当我们想去修改一个解锁方式，我们只需要修改相应的算法就可以了，甚至不用去触碰其它的算法。当一种算法被破解，或被用户主动设置为不安全后，可以立刻停止改解锁方法的验证。而且每一种解锁方法的算法可以被复用到所有不同的设备中。</p>
<p>这种设计模式我们称之为 Strategy Pattern (策略模式)。</p>
<blockquote>
<p><strong>Strategy Pattern</strong> is a software design pattern that enables an algorithm’s behavior to be selected at runtime.</p>
</blockquote>
<p>在不同的场景中，一个相同的目的有不同的方法可以达到（不同算法可以实现）。这种模式就叫做策略模式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> UnlockAlg {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> unlock() = <span class="number">0</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class</span> FingerprintUnlockAlg : <span class="keyword">public</span> UnlockAlg {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> unlock() {</div><div class="line">        <span class="comment">// 指纹解锁的实现</span></div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class</span> FaceUnlockAlg : <span class="keyword">public</span> UnlockAlg {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> unlock() {</div><div class="line">        <span class="comment">// 人脸识别解锁的实现</span></div><div class="line">    }</div><div class="line">};</div></pre></td></tr></table></figure>

<p>以上是解锁算法的 interfaces，我们还可以继承更多的方法，也可以继承更详细的算法，比如<code>class PasswordUnlockAlg : public UnlockAlg</code> 还可以继承给高级密码解锁（如 iPhone 的全键盘解锁）和一般密码解锁（如 iPhone 的默认九宫格键盘解锁）如 <code>class SimplePasswordUnlockAlg : public PasswordUnlockAgl</code> 以及 <code>class StrongPasswordUnlockAlg : public PasswordUnlockAgl</code>。</p>
<p>接下来我们实现这些算法的应用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Unlock {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Unlock (UnlockAlg* strategy) : strategy_ (strategy) {}</div><div class="line">    <span class="keyword">void</span> setstrategy_ (UnlockAlg* strategy) {</div><div class="line">        strategy_ = strategy;</div><div class="line">    }</div><div class="line">    <span class="keyword">void</span> unlock() {</div><div class="line">        strategy_ -&gt; unlock();</div><div class="line">    }</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    UnlockAlg* strategy_;</div><div class="line">}；</div><div class="line"></div><div class="line"><span class="keyword">int</span> main (<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) {</div><div class="line">    FingerprintUnlockAlg FingerprintUnlockAlg;</div><div class="line">    FaceUnlockAlg FaceUnlockAlg;</div><div class="line">    <span class="comment">// 更多解锁算法</span></div><div class="line"></div><div class="line">    Unlock FingerprintUnlock (&FingerprintUnlockAlg);</div><div class="line">    Unlock FaceUnlock (&FaceUnlockAlg);</div><div class="line">    <span class="comment">// 更多解锁实现</span></div><div class="line"></div><div class="line">    FingerprintUnlock.unlock();   <span class="comment">// 采用指纹解锁方法</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>至此，我们按照 Strategy Pattern 的理念设计，实现了解锁算法的简单化。这种方法也大量应用于密码验证（数字串密码、文件密码、IP密码等），政府、机构文件申请表（地区州省不同，所在地不同等）。当我们的一个动作，在不同场景下需要有不同的方法来处理时，我们就可以采用 Strategy 的建议。</p>
<hr>
<h2 id="_医院前台_-_Observer"><a id="observer pattern"></a> 医院前台 - Observer</h2>
<p><a href="#content">跳到所有模式目录</a> / <a href="#top">回到全文顶端</a></p>
<p>一个病人来到医院，就知道自己胃痛，也不知道应该去哪里。于是就整个医院碰到屋子就进去问，一个诊室接着一个诊室的问，最后好不容易问清楚。后来这个病人想去用厕所，可是也不知道在哪里，就沿着走廊一间一间的找。这样病人的效率也低，工作人员也总被问到无关紧要的问题，效率和体验实在是大打折扣。</p>
<p>这时你会问：医院不是都有接待的前台吗？一般去了医院，学校，或者大公司都可以问前台你应该去哪，或者对你的问题直接有回应（比如打电话通知办公室）。这种行为模式就被四人帮定义为：观察者模式（Observer Pattern）。</p>
<p><img src="https://dl.dropboxusercontent.com/u/43681877/temp/observer.jpg" alt="一般模式转换为观察者模式示例"></p>
<blockquote>
<p><strong>Observer Pattern</strong> is a software design pattern in which an object, <em>called</em> the subject, <em>maintains</em> a list of its dependents, <em>called</em> observers, and <em>notifies</em> them automatically of any state changes, usually by calling one of their methods.</p>
</blockquote>
<p>也就是说，一个 Observer class 管理 (maintain) 所有相依于它的物件 (dependents)，并通过呼叫 (calls) 这些物件的方法 (methods)，在本身状态 (state) 发生改变的时候主动发出通知 (notification)。</p>
<p>在我们的例子中，也就是总接待前台管理所有的诊室接待，并在有病人提出请求的时候打电话通知诊室，以询问该把这位病人送到哪里并提出建议，然后前台再把得到的信息转达给病人。</p>
<p><img src="https://dl.dropboxusercontent.com/u/43681877/temp/observer2.jpg" alt="观察者模式的实际动作（Action）"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Observer {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> update () = <span class="number">0</span>; <span class="comment">// 为观察者定义 Pure virtual 方法</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class</span> Patient {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">void</span> come (Observer*);</div><div class="line">    <span class="keyword">void</span> leave (Observer*);</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">void</span> notify();</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">typedef</span> std::<span class="stl_container"><span class="built_in">set</span>&lt;Observer*&gt;</span> Observers;</div><div class="line">    Observers observers_;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来我们实现病人的方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Patient::come (Observer* o) {</div><div class="line">    observers_.insert(o);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Patient::leave (Observer* o) {</div><div class="line">    observer_.erase(o);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Patient::notify () {</div><div class="line">    Observers::iterator i; </div><div class="line">    <span class="comment">// 这里我们又用到了Iterator Pattern来更新 (update) 每一个 observer</span></div><div class="line">    <span class="keyword">for</span> (i = observers_.begin(); i != observers_.end(); i++) {</div><div class="line">        (*i) -&gt; update ();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来的一部分，我们要顺水推舟介绍一下 MVC（Model-View-Controller Pattern）。这是目前被大量应用的一种设计模式，我们熟知的大部分网络应用框架（Web application framework）都是 MVC 的产物。而 MVC 就是基于 Observer 的一种软件设计框架。</p>
<hr>
<h2 id="_Observer_Pattern_的应用_-_Model-View-Controller"><a id="mvc pattern"></a> Observer Pattern 的应用 - Model-View-Controller</h2>
<p><a href="#content">跳到所有模式目录</a> / <a href="#top">回到全文顶端</a></p>
<p>因为MVC并不是一种我们要说到的设计模式，读者可以<a href="#composite pattern">跳过这段</a>。</p>
<p>如果我们现在要设计一个微博 (Mini Blog，如Twitter) 网页应用，你一定不希望是这样的逻辑：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if submitButton is clicked())</div><div class="line">    if inputField is Valid())</div><div class="line">        <span class="operator"><span class="keyword">insert</span> inputField <span class="keyword">into</span> <span class="keyword">database</span></span></div><div class="line">        <span class="keyword">add</span> box <span class="keyword">in</span> html</div><div class="line">        <span class="keyword">add</span> <span class="keyword">input</span> <span class="keyword">in</span> the box <span class="keyword">in</span> html</div><div class="line">        refresh page</div><div class="line">        clean inputField</div><div class="line">// more <span class="keyword">and</span> more <span class="keyword">and</span> more <span class="keyword">and</span> more...</div></pre></td></tr></table></figure>

<p>当逻辑复杂之后，那整个应用就是完全没有办法维护，效率低下的一堆垃圾。那么我们怎么使用一些模式来设计这个应用呢？对于这种有互动的网页应用，我们可以提供下面这种模式。</p>
<p><img src="https://dl.dropboxusercontent.com/u/43681877/temp/mvc.jpg" alt="MVC一般图示"></p>
<blockquote>
<p>A <strong>controller</strong> can send commands to the model to update the model’s state (e.g., editing a document). It can also send commands to its associated view to change the view’s presentation of the model (e.g., by scrolling through a document).</p>
</blockquote>
<p>Controller 负责转发请求，对请求进行处理。他扮演着 Observer 的功能。</p>
<blockquote>
<p>A <strong>model</strong> notifies its associated views and controllers when there has been a change in its state. This notification allows the views to produce updated output, and the controllers to change the available set of commands. In some cases an MVC implementation might instead be “passive,” so that other components must poll the model for updates rather than being notified.</p>
</blockquote>
<p>Model 是成语的核心部分，他提供应有的功能（如实现算法）和管理数据（如存入数据库一句话）。这里我们可以看到，这里MVC应用了 <a href="#strategy pattern">Strategy</a> 设计模式。把 Model 和 Controller 封装在一个系统中，Model 中含有各种算法和实现方法，而 controller 来调用这些算法。</p>
<blockquote>
<p>A <strong>view</strong> requests information from the model that it uses to generate an output representation to the user.</p>
</blockquote>
<p>View 最好理解 - 所见即所得。你所能看到的图形、文字、对话框、输入框都由 View 来管理。（这里涉及到我们之后会介绍到的 <a href="#composite pattern">Composite</a> 设计模式。）</p>
<p>因为实现 MVC 要使用很多图形操作界面的知识，这里我们就不具体到代码，感兴趣的读者可以移步 <a href="http://zh.wikipedia.org/wiki/MVC" target="_blank" rel="external">Wikipedia</a> 阅读更多。</p>
<hr>
<h2 id="_炸鸡套餐，聪明消费_-_Decorator"><a id="decorator pattern"></a> 炸鸡套餐，聪明消费 - Decorator</h2>
<p><a href="#content">跳到所有模式目录</a> / <a href="#top">回到全文顶端</a></p>
<p>当你去一家餐厅的时候，你一定希望买到价钱比较合算的餐点。这时候，餐厅一般不会采用直接打折的方式，相反，餐厅会提供给你套餐。比如，如果你点了炸鸡，那么再加一瓶可乐，就要比单独买可乐价钱更优惠。这种聪明的方式就是我们接下来要介绍的设计模式。</p>
<p><img src="https://dl.dropboxusercontent.com/u/43681877/temp/decorator.jpg" alt="Decorator Pattern"></p>
<blockquote>
<p><strong>Decorator Pattern</strong> is a design pattern that allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class.</p>
</blockquote>
<p>也就是说，在上面的例子中，饮料和小食就是我们的 Decorator，汉堡和炸鸡就是 Original Object。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Baverage : <span class="keyword">public</span> VisualComponent { <span class="comment">// Baverage 就是 Decorator</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> order ();</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    Baverage (VisualComponent* comp): component_ (comp) { }</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    VisualComponent* component_;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">void</span> Baverage::order () {</div><div class="line">    component_ -&gt; order ();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码中，我们定义了 Decorator。我们不使用继承，而是组合的方式加入我们的 component 中。下面的例子是我们创建饮料这个 Decorator。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Cola : <span class="keyword">public</span> Baverage {</div><div class="line">    <span class="keyword">enum</span> Style { DEFAULT, ... } style_;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Cola (VisualComponent *v, Style s = DEFAULT):</div><div class="line">        Baverage(v), style_ (s) { }</div><div class="line">    <span class="keyword">void</span> order ();</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">void</span> cola::order () {</div><div class="line">    Baverage::order ();</div><div class="line">    <span class="comment">// 点一个可乐作为我们饮料</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是 Decorator 模式的实现，其不采用继承，而采用组合的方式，动态的为物件添加或修改功能。</p>
<hr>
<h2 id="_树状结构_-_Composite"><a id="composite pattern"></a> 树状结构 - Composite</h2>
<p><a href="#content">跳到所有模式目录</a> / <a href="#top">回到全文顶端</a></p>
<p>树状图是人类历史上最伟大的发现之一。它有效地描述了很多复杂的结构，比如员工表、家谱、书籍目录、字典等等。那么软件设计中，当然我们也会借鉴这种结构，我们称之为组合模式（Composite Pattern）。</p>
<p>几乎所有可以用树状图描述的结构，都可以用组合模式来设计。比如 CS247 的文件夹：<br><img src="https://dl.dropboxusercontent.com/u/43681877/temp/composite.jpg" alt="CS247的系统文件夹"></p>
<blockquote>
<p><strong>Composite Pattern</strong> describes that a group of objects is to be treated in the same way as a single instance of an object. </p>
</blockquote>
<p>也可以说：</p>
<blockquote>
<p>Composite Pattern gives the client access to all member types in a compound object via a <strong>uniform interface</strong>.</p>
</blockquote>
<p><img src="https://dl.dropboxusercontent.com/u/43681877/temp/composite2.jpg" alt="Composite Pattern 的基本思路"></p>
<p>使用 Composite Pattern 可以大量降低复杂系统的成本，前提是这个系统类似树类结构，并且对树中所有元素一视同仁。实际设计中，所有的 Composite 相比 Leaf 应该多有 Add, Remove, GetChild 等二级操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> CS247 {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> ~CS247() {}</div><div class="line"></div><div class="line">    <span class="comment">// Leaf (文件) 的方法</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> openAsPDF() <span class="keyword">const</span> { <span class="keyword">return</span> <span class="number">0</span>;}</div><div class="line"></div><div class="line">    <span class="comment">// Component (文件夹) 的方法</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> add(CS247*) { }</div><div class="line">    <span class="keyword">virtual</span> CS247* getFile(<span class="keyword">int</span>) <span class="keyword">const</span> { <span class="keyword">return</span> <span class="number">0</span>;}</div><div class="line"></div><div class="line">    <span class="comment">// Leaf 和 Component 共有的方法</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> print() <span class="keyword">const</span> { std::<span class="built_in">cout</span> &lt;&lt; name_; }</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    CS247 (<span class="keyword">const</span> std::<span class="built_in">string</span> &fileName);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::<span class="built_in">string</span> fileName_;</div><div class="line">};</div></pre></td></tr></table></figure>

<p>值得注意的是，根据 Composite 的定义，所有的 Component 应该被一视同仁。不过出于安全 (safety) 和实用性 (making sense) 考虑，我们应该禁止 Leaf 下加入新的 component（试想在一个文件上加入文件夹是没有意义的，或说做不到的）。这样就有了两种说法：</p>
<blockquote>
<p><strong>Uniformity</strong>: preserving the illusion that component objects can be treated the same way.</p>
</blockquote>
<p><strong>统一说</strong>：为满足 Composite Pattern 的基本定义，我们应该允许（或预留）使所有 component 有相同的方法。</p>
<blockquote>
<p><strong>Safety</strong>: avoiding cases where the client attempts to do something meaningless, like adding components to Leaf objects.</p>
</blockquote>
<p><strong>安全说</strong>：为避免做没有任何意义的方法，leaf 和 components 应该分别有不同方法限制不安全或不实用的操作。</p>
<p>基本的 Composite 模式就是这样。而 Composite 最经常的用法是与 <a href="#iterator pattern">Iterator</a> 共同使用。（例如：用来遍历树中所有的元素）</p>
<p><img src="https://dl.dropboxusercontent.com/u/43681877/temp/composite3.jpg" alt="当 Composite 遇到 Iterator"></p>
<p>代码上，我们首先创建 Leaf 和 Component 的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">CS247 *f = <span class="keyword">new</span> File;</div><div class="line">Iterator *iter = f -&gt; createIterator();</div><div class="line">iter -&gt; first();</div><div class="line"><span class="keyword">while</span> ( iter -&gt; hasNext() ) {</div><div class="line">    CS247 *c = iter -&gt; next();</div><div class="line">    <span class="comment">// 在这里对 c 做些什么</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 这段代码对于上面是重复的，只有 File 变成了 Folder</span></div><div class="line">CS247 *f = <span class="keyword">new</span> Folder;</div><div class="line">Iterator *iter = f -&gt; createIterator();</div><div class="line">iter -&gt; first();</div><div class="line"><span class="keyword">while</span> ( iter -&gt; hasNext() ) {</div><div class="line">    CS247 *c = iter -&gt; next();</div><div class="line">    <span class="comment">// 在这里对 c 做些什么</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来，composite 下的元素会创建自己的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Iterator* File::createIterator() {</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FileIterator(<span class="keyword">this</span>);</div><div class="line">}</div><div class="line"></div><div class="line">Iterator* Folder::createIterator() {</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FolderIterator(<span class="keyword">this</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后让我们来一起创建 File 的迭代器类（继承于 Iterator）。之后，我们会先创建 Folder 的特殊功能，再创建 Folder 的迭代器类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> FileIterator : <span class="keyword">public</span> Iterator {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    FileIterator(File* file) : file_(file), cursor_(file) {}</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> first() { cursor_ = file_; }</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">bool</span> hasNext() { <span class="keyword">return</span> (cursor_ != <span class="number">0</span>); }</div><div class="line">    <span class="keyword">virtual</span> CS247* next();</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    File* file_;</div><div class="line">    File* cursor_;</div><div class="line">};</div><div class="line"></div><div class="line">CS247* FileIterator::next() {</div><div class="line">    <span class="keyword">if</span> ( hasNext() ) {</div><div class="line">        cursor = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> file_;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>下面我们实现 Folder 的功能（比如添加，删除下面的文件）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Folder : <span class="keyword">public</span> CS247 {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> add( CS247* newFile ) { files_.push_back( newFile ); }</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">int</span> size() <span class="keyword">const</span> { <span class="keyword">return</span> files_.size(); }</div><div class="line">    <span class="keyword">virtual</span> CS247* getChild(<span class="keyword">int</span> i) <span class="keyword">const</span> { <span class="keyword">return</span> files_.at(i); }</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::<span class="stl_container"><span class="built_in">vector</span>&lt;CS247*&gt;</span> files_;</div><div class="line">};</div></pre></td></tr></table></figure>

<p>接下来是 Folder 的迭代器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> FolderIterator : <span class="keyword">public</span> Iterator {</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    CS247* files_;                <span class="comment">// 指向 composite 的指针 </span></div><div class="line">    <span class="keyword">struct</span> IterNode;              <span class="comment">// &lt;node, cursor&gt; </span></div><div class="line">    std::<span class="stl_container"><span class="built_in">stack</span>&lt;IterNode*&gt;</span> istack; <span class="comment">// 迭代器的容器，我们采用stack</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    FolderIterator(CS247* c) : files_(c) { first(); }</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> first();         <span class="comment">// 初始化迭代器容器 </span></div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">bool</span> hasNext();</div><div class="line">    <span class="keyword">virtual</span> CS247* next();</div><div class="line">};</div></pre></td></tr></table></figure>

<p>然后我们实现具体的功能，首先创建一个迭代器的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> FolderIterator::IterNode {</div><div class="line">    CS247 *node_;</div><div class="line">    <span class="keyword">int</span> cursor_;      <span class="comment">// 从 from -1 到 node_ -&gt; size();</span></div><div class="line">    IterNode(CS247 *c) : node_(c), cursor_(-<span class="number">1</span>) {}</div><div class="line">};</div></pre></td></tr></table></figure>

<p>接下来我们初始化它（定义<code>first()</code>, <code>hasNext()</code> 与 <code>next()</code>）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// first(); 初始化并指向队列中的第一个节点。</span></div><div class="line"><span class="keyword">void</span> FolderIterator::first() {</div><div class="line">    <span class="keyword">while</span> ( !istack.empty() ) {</div><div class="line">        istack.pop();</div><div class="line">    }</div><div class="line">    istack.push( <span class="keyword">new</span> IterNode( files_ ) );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// next(); 寻找下一个节点。</span></div><div class="line">CS247* FolderIterator::next() { </div><div class="line">    <span class="keyword">if</span> ( hasNext() ) {               <span class="comment">// 检查是否还有更多的 node</span></div><div class="line">        IterNode* top = istack.top();</div><div class="line">        istack.pop();</div><div class="line">    </div><div class="line">        <span class="comment">// 指针指向节点</span></div><div class="line">        <span class="keyword">if</span> (top -&gt; cursor_ == -<span class="number">1</span>) {</div><div class="line">            top -&gt; cursor_ += <span class="number">1</span>;</div><div class="line">            istack.push(top);</div><div class="line">            <span class="keyword">return</span> top-&gt;node_;       <span class="comment">// 返回这个节点</span></div><div class="line">        }</div><div class="line">    </div><div class="line">        <span class="comment">// 指针指向节点的 child （对于composite来说）</span></div><div class="line">        CS247 *elem = top -&gt; node_ -&gt; getChild(top -&gt; cursor_);</div><div class="line">        top -&gt; cursor_ += <span class="number">1</span>;</div><div class="line">        istack.push(top); </div><div class="line">        istack.push(<span class="keyword">new</span> IterNode(elem)); </div><div class="line">        <span class="keyword">return</span> next();</div><div class="line">    }</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// hasNext(); 检查是否到达最后一个节点。</span></div><div class="line"><span class="keyword">bool</span> FolderIterator::hasNext() {</div><div class="line">    <span class="keyword">while</span> ( !istack.empty() )  {</div><div class="line">        Iter *top = istack.top();</div><div class="line">        <span class="keyword">if</span> ( top -&gt; cursor_ &lt; top -&gt; node_ -&gt; size() ) {</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">        istack.pop();</div><div class="line">        <span class="keyword">delete</span> top; </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<h2 id="_新时代，全球化_-_Template_Method"><a id="template method pattern"></a> 新时代，全球化 - Template Method</h2>
<p><a href="#content">跳到所有模式目录</a> / <a href="#top">回到全文顶端</a></p>
<p>假设，我们在写一个汇率软件，因为汇率涉及到不同国家，不同国家又有不同的语言，为了让大家都能看懂，程序中的显示要符合不同语言的要求。那么，一种很直白的编程方式就出现了：</p>
<p>（以下的例子中我们要在屏幕上 print “US$” 的意思，中文为：美元，英文为：United States Dollar，法文为：Dollar des États-Unis）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> l = getLanguage(); <span class="comment">// 取得语言编码，如中文为1，英文为2，法文为3</span></div><div class="line"></div><div class="line"><span class="comment">// 输出 $5</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"5"</span>;</div><div class="line"><span class="keyword">switch</span> (l) { </div><div class="line">    <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" United States Dollar"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" Dollar des États-Unis"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" 美元"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 输出 $12</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"12"</span>;</div><div class="line"><span class="keyword">switch</span> (l) { </div><div class="line">    <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" United States Dollar"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" Dollar des États-Unis"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" 美元"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果用这种办法，如果以后要添加语言，或者修改不准确的语言都要重新修改源代码。为避免这种情况，我们采用以下这种办法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> usdollar;</div><div class="line"><span class="keyword">int</span> l = getLanguage();</div><div class="line"><span class="keyword">if</span> (l == <span class="number">1</span>) usdollar = <span class="string">" 美元"</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (l == <span class="number">2</span>) usdollar = <span class="string">" United States Dollar"</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (l == <span class="number">3</span>) usdollar = <span class="string">" Dollar des États-Unis"</span>;</div><div class="line"><span class="keyword">else</span> usdollar = <span class="string">" 美元"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 输出 $5</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"5"</span> &lt;&lt; usdollar;</div><div class="line"></div><div class="line"><span class="comment">// 输出 $12</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"12"</span> &lt;&lt; usdollar;</div></pre></td></tr></table></figure>

<p>由此可见，我们节省了很多的空间。那么以上这种思路就是我们现在要介绍的设计模式 Template Method Pattern （模版方法模式）。</p>
<p><img src="https://dl.dropboxusercontent.com/u/43681877/temp/composite2.jpg" alt="Template Method Pattern 示例"></p>
<blockquote>
<p><strong>Template Method Pattern</strong> is a behavioral design pattern that defines the program skeleton of an algorithm in a method, called template method, which defers some steps to subclasses.</p>
</blockquote>
<p>我们刚才举得例子是很简单的一个想法，而实用 template method pattern 设计的软件我们可以想象最开始 factory method pattern 的例子。这两种设计模式有异曲同工之处。Template method 比较看中的是父类描述骨架，构建抽象的方法留到子类来进行实现。Factory Method 将实际要建立的物件留到子类解决，Template Method 则是将抽象的流程或算法留到子类完成。</p>
<p>从面向对象语言的角度，Template Method Pattern 是软件封装性最好的例子。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jobmine.github.io/2014/08/08/software-pattern/" data-id="0qzyz7etdfd6cxi5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
  
</article>

</section>
      </div>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog//" class="mobile-nav-link">杂记</a>
  
    <a href="/blog//" class="mobile-nav-link">个人</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/blog/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/blog/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>